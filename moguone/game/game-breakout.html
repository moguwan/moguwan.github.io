<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>Neon Breakout Endless</title>
    <style>
        body {
            background: #090a0f;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', sans-serif;
            color: white;
        }
        #game-container { position: relative; }
        canvas {
            border: 2px solid rgba(0, 210, 255, 0.3);
            background: radial-gradient(circle at bottom, #1a1c29 0%, #000 100%);
            box-shadow: 0 0 50px rgba(0, 210, 255, 0.1);
            border-radius: 4px;
            cursor: crosshair;
        }
        .ui {
            position: absolute; top: 20px; width: 100%; display: flex; justify-content: space-between; padding: 0 30px;
            box-sizing: border-box; pointer-events: none; font-size: 20px; font-weight: bold; color: #fff; text-shadow: 0 0 10px #fff;
            z-index: 5;
        }
        .overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            background: rgba(0,0,0,0.85); backdrop-filter: blur(5px); z-index: 10; cursor: default;
        }
        .btn {
            background: linear-gradient(90deg, #ff00cc, #333399); border: none; padding: 15px 50px;
            color: white; font-size: 20px; font-weight: bold; border-radius: 30px; cursor: pointer;
            margin-top: 20px; box-shadow: 0 0 20px rgba(255, 0, 204, 0.4); transition: 0.2s;
        }
        .btn:hover { transform: scale(1.1); box-shadow: 0 0 40px rgba(255, 0, 204, 0.6); }
        
        .level-flash {
            position: absolute; top: 40%; width: 100%; text-align: center;
            font-size: 80px; font-weight: 800; color: #fff; text-shadow: 0 0 30px #00d2ff;
            opacity: 0; pointer-events: none; transition: opacity 0.5s; z-index: 8;
        }

        .esc-hint {
            position: absolute; bottom: 10px; width: 100%; text-align: center; 
            color: rgba(255,255,255,0.3); font-size: 12px; pointer-events: none;
        }
    </style>
</head>
<body>

    <div id="game-container">
        <div class="ui">
            <div>SCORE: <span id="score">0</span></div>
            <div style="color: #00d2ff">LEVEL: <span id="level">1</span></div>
            <div>LIVES: <span id="lives">3</span></div>
        </div>
        
        <div id="level-text" class="level-flash">LEVEL 1</div>
        <canvas id="canvas" width="800" height="600"></canvas>
        <div class="esc-hint">Êåâ ESC ÈîÆÊöÇÂÅú/ÈáäÊîæÈº†Ê†á</div>

        <div id="start-screen" class="overlay">
            <h1 style="font-size: 50px; text-shadow: 0 0 20px #ff00cc; margin:0;">NEON BREAKOUT</h1>
            <p style="color:#00d2ff; letter-spacing: 2px;">ENDLESS MODE</p>
            <button class="btn" onclick="startGame()">CLICK TO START</button>
        </div>

        <div id="game-over" class="overlay" style="display: none;">
            <h1 id="over-title">GAME OVER</h1>
            <p>Final Score: <span id="final-score">0</span></p>
            <button class="btn" onclick="location.reload()">RETRY</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score');
        const levelEl = document.getElementById('level');
        const livesEl = document.getElementById('lives');
        const levelText = document.getElementById('level-text');

        let score = 0;
        let lives = 3;
        let level = 1;
        let isRunning = false;
        let baseSpeed = 2.5; 
        
        let balls = [];
        let particles = [];
        let powerUps = [];
        let bricks = [];

        const paddle = {
            width: 120, height: 12, x: canvas.width/2 - 60, y: canvas.height - 40, 
            dx: 0, color: '#00d2ff', originalWidth: 120
        };

        const brickInfo = { w: 0, h: 20, padding: 8, offsetX: 45, offsetY: 60, rows: 5, cols: 9 };

        class Ball {
            constructor(x, y, dx, dy) {
                this.x = x; this.y = y; this.dx = dx; this.dy = dy;
                this.size = 7; this.active = true;
            }
            draw() {
                ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI*2);
                ctx.fillStyle = "#fff"; ctx.shadowBlur = 10; ctx.shadowColor = "#fff";
                ctx.fill(); ctx.shadowBlur = 0;
            }
            update() {
                this.x += this.dx; this.y += this.dy;
                if (this.x + this.size > canvas.width) { this.x = canvas.width - this.size; this.dx *= -1; }
                if (this.x - this.size < 0) { this.x = this.size; this.dx *= -1; }
                if (this.y - this.size < 0) { this.y = this.size; this.dy *= -1; }
                
                if (this.y - this.size > canvas.height) this.active = false;

                if (this.x > paddle.x && this.x < paddle.x + paddle.width && 
                    this.y + this.size >= paddle.y && this.y - this.size <= paddle.y + paddle.height) {
                    
                    this.dy = -Math.abs(this.dy);
                    this.y = paddle.y - this.size;
                    
                    let hitPoint = this.x - (paddle.x + paddle.width/2);
                    this.dx = hitPoint * 0.12; 
                }
                checkBrickCollision(this);
            }
        }

        function initLevel() {
            balls = [new Ball(canvas.width/2, canvas.height-50, baseSpeed, -baseSpeed)];
            particles = [];
            powerUps = [];
            paddle.width = paddle.originalWidth;
            
            levelText.innerText = `LEVEL ${level}`;
            levelText.style.opacity = 1;
            setTimeout(() => levelText.style.opacity = 0, 2000);

            brickInfo.rows = Math.min(4 + level, 10);
            
            bricks = [];
            brickInfo.w = (canvas.width - (brickInfo.offsetX*2) - (brickInfo.padding * (brickInfo.cols-1))) / brickInfo.cols;
            
            let hardChance = (level - 1) * 0.1;

            for(let c=0; c<brickInfo.cols; c++) {
                bricks[c] = [];
                for(let r=0; r<brickInfo.rows; r++) {
                    const hue = (r / brickInfo.rows) * 300;
                    let isHard = Math.random() < hardChance;
                    
                    bricks[c][r] = { 
                        x: 0, y: 0, 
                        status: 1, 
                        health: isHard ? 2 : 1,
                        type: isHard ? 'hard' : 'normal',
                        color: isHard ? '#aaa' : `hsl(${hue}, 80%, 55%)`
                    };
                }
            }
        }

        async function startGame() {
            try { 
                await canvas.requestPointerLock(); 
            } catch (e) {
                console.log("Pointer lock failed/denied", e);
            }
            document.getElementById('start-screen').style.display = 'none';
            document.getElementById('game-over').style.display = 'none';
            
            score = 0; scoreEl.innerText = 0;
            lives = 3; livesEl.innerText = 3;
            level = 1; levelEl.innerText = 1;
            baseSpeed = 2.5; 

            initLevel();
            isRunning = true;
            loop();
        }

        // Ê†∏ÂøÉ‰øÆÊîπÔºöÁ°Æ‰øùÊåáÈíàÈîÅÂÆöÁä∂ÊÄÅÊ≠£Á°ÆÊéßÂà∂Ê∏∏ÊàèËøêË°å
        document.addEventListener('pointerlockchange', () => {
            if (document.pointerLockElement === canvas) {
                isRunning = true;
                loop(); // ÈáçÊñ∞Ëé∑ÂæóÁÑ¶ÁÇπÊó∂Â∞ùËØïÈáçÂêØÂæ™ÁéØ
            } else {
                isRunning = false; // Â§±ÂéªÁÑ¶ÁÇπÊöÇÂÅú
            }
        });
        
        canvas.addEventListener('click', () => {
            if (!document.pointerLockElement && lives > 0) canvas.requestPointerLock();
        });

        function checkBrickCollision(ball) {
            for(let c=0; c<brickInfo.cols; c++) {
                for(let r=0; r<brickInfo.rows; r++) {
                    let b = bricks[c][r];
                    if(b.status === 1) {
                        let bX = (c * (brickInfo.w + brickInfo.padding)) + brickInfo.offsetX;
                        let bY = (r * (brickInfo.h + brickInfo.padding)) + brickInfo.offsetY;
                        
                        if(ball.x > bX && ball.x < bX + brickInfo.w && 
                           ball.y > bY && ball.y < bY + brickInfo.h) {
                            
                            ball.dy *= -1; 
                            b.health--;
                            
                            if (b.health <= 0) {
                                b.status = 0; 
                                score += b.type === 'hard' ? 20 : 10;
                                scoreEl.innerText = score;
                                createExplosion(bX + brickInfo.w/2, bY + brickInfo.h/2, b.type === 'hard' ? '#fff' : b.color);
                                
                                if(Math.random() < 0.15) powerUps.push(new PowerUp(bX, bY, 'multiball'));
                                else if (Math.random() < 0.08) powerUps.push(new PowerUp(bX, bY, 'widepaddle'));
                            } else {
                                createExplosion(bX + brickInfo.w/2, bY + brickInfo.h/2, '#fff');
                                b.color = '#ff0055'; 
                            }
                        }
                    }
                }
            }
        }

        class PowerUp {
            constructor(x, y, type) {
                this.x = x; this.y = y; this.type = type;
                this.dy = 2; this.size = 20; this.active = true;
            }
            update() {
                this.y += this.dy;
                if (this.x + this.size > paddle.x && this.x < paddle.x + paddle.width &&
                    this.y + this.size > paddle.y && this.y < paddle.y + paddle.height) {
                    activatePowerUp(this.type); this.active = false;
                }
                if (this.y > canvas.height) this.active = false;
            }
            draw() {
                ctx.fillStyle = this.type === 'multiball' ? '#0f0' : '#f0f';
                ctx.shadowBlur = 10; ctx.shadowColor = ctx.fillStyle;
                ctx.fillRect(this.x, this.y, this.size, this.size);
                ctx.fillStyle = "#000"; ctx.font = "bold 12px Arial";
                ctx.fillText(this.type === 'multiball' ? 'x3' : 'W', this.x+2, this.y+14);
                ctx.shadowBlur = 0;
            }
        }

        function activatePowerUp(type) {
            if (type === 'multiball') {
                if (balls.length > 0) {
                    let b = balls[0];
                    balls.push(new Ball(b.x, b.y, -Math.abs(b.dx), b.dy)); 
                    balls.push(new Ball(b.x, b.y, Math.abs(b.dx), b.dy));
                }
            } else if (type === 'widepaddle') {
                paddle.width = 250;
                setTimeout(() => paddle.width = paddle.originalWidth, 8000); 
            }
        }

        function createExplosion(x, y, color) {
            for(let i=0; i<6; i++) {
                particles.push({
                    x: x, y: y, color: color, dx: (Math.random()-0.5)*4, dy: (Math.random()-0.5)*4, life: 1.0
                });
            }
        }

        function loop() {
            if (!isRunning) return;

            ctx.fillStyle = 'rgba(0,0,0,0.3)'; ctx.fillRect(0, 0, canvas.width, canvas.height);

            // ÁªòÂà∂Á†ñÂùó
            let bricksLeft = 0;
            for(let c=0; c<brickInfo.cols; c++) {
                for(let r=0; r<brickInfo.rows; r++) {
                    let b = bricks[c][r];
                    if(b.status === 1) {
                        bricksLeft++;
                        let bX = (c * (brickInfo.w + brickInfo.padding)) + brickInfo.offsetX;
                        let bY = (r * (brickInfo.h + brickInfo.padding)) + brickInfo.offsetY;
                        
                        ctx.fillStyle = b.color; 
                        ctx.shadowBlur = b.type === 'hard' ? 0 : 5; 
                        ctx.shadowColor = ctx.fillStyle;
                        
                        if (b.type === 'hard') {
                            ctx.strokeStyle = '#fff';
                            ctx.lineWidth = 2;
                            ctx.strokeRect(bX, bY, brickInfo.w, brickInfo.h);
                        }
                        
                        ctx.fillRect(bX, bY, brickInfo.w, brickInfo.h); 
                        ctx.shadowBlur = 0;
                    }
                }
            }

            // ÁªòÂà∂Êå°Êùø
            ctx.fillStyle = paddle.color; ctx.shadowBlur = 15; ctx.shadowColor = paddle.color;
            ctx.fillRect(paddle.x, paddle.y, paddle.width, paddle.height); ctx.shadowBlur = 0;

            // Êõ¥Êñ∞ÁêÉ
            balls.forEach(b => { b.update(); b.draw(); });
            
            // Êõ¥Êñ∞ÈÅìÂÖ∑
            powerUps.forEach(p => { p.update(); p.draw(); });
            balls = balls.filter(b => b.active);
            powerUps = powerUps.filter(p => p.active);

            // Êõ¥Êñ∞Á≤íÂ≠ê
            for (let i = particles.length - 1; i >= 0; i--) {
                let p = particles[i]; p.x += p.dx; p.y += p.dy; p.life -= 0.05;
                ctx.globalAlpha = p.life; ctx.fillStyle = p.color;
                ctx.fillRect(p.x, p.y, 3, 3); ctx.globalAlpha = 1;
                if (p.life <= 0) particles.splice(i, 1);
            }

            // ============================================
            // üî¥ ÂÖ≥ÈîÆ‰øÆÂ§çÔºöÁîüÂëΩÊ£ÄÊµãÂíåÈÄöÂÖ≥Ê£ÄÊµãÈÉΩÂú® LOOP ÂÜÖÈÉ® üî¥
            // ============================================
            
            if (balls.length === 0) {
                lives--; livesEl.innerText = lives;
                if (lives > 0) {
                    document.exitPointerLock(); 
                    balls.push(new Ball(canvas.width/2, canvas.height-50, baseSpeed, -baseSpeed));
                    paddle.x = canvas.width/2 - paddle.width/2;
                    // ÊöÇÂÅúÁ≠âÂæÖÁé©ÂÆ∂ÁÇπÂáª
                    isRunning = false; 
                } else {
                    isRunning = false; 
                    document.exitPointerLock();
                    
                    // ÂèëÈÄÅÂàÜÊï∞
                    if (window.parent) {
                        window.parent.postMessage({
                            type: 'GAME_OVER',
                            game: 'breakout',
                            score: score,
                            extra: `ÂÖ≥Âç°: ${level}`
                        }, '*');
                    }

                    document.getElementById('final-score').innerText = score;
                    document.getElementById('game-over').style.display = 'flex';
                }
            }
            
            // ÂÖ≥Âç°ËÉúÂà©Ê£ÄÊµã
            if(bricksLeft === 0) {
                level++;
                levelEl.innerText = level;
                baseSpeed *= 1.1; 
                initLevel(); 
            }
            
            if (isRunning) requestAnimationFrame(loop);
        }

        document.addEventListener('mousemove', e => {
            if (document.pointerLockElement === canvas) {
                paddle.x += e.movementX;
                if (paddle.x < 0) paddle.x = 0;
                if (paddle.x + paddle.width > canvas.width) paddle.x = canvas.width - paddle.width;
            }
        });

    </script>
</body>
</html>